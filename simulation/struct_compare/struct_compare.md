# 課題2

## ・何が起きているか

構造体 Obj は8バイトのdouble、1バイトのchar、8バイトのdoubleをメンバとして保持しているが、アライメントによって、char型の変数の後ろに7バイト分のパディングがなされる。trickの前は、このパディング領域も含めてメモリ情報が一致しているため、memcmp()関数の結果はTrueとなった。しかし、trickによって、パディング領域の不定値が書き換えられてしまったため、メンバ本体の値に変動はないが、メモリ全体を比較すると不一致になってしまった。

## ・構造体の比較における注意点

前述の通り、構造体ではメンバの型のバイト数によって自動でパディングがなされるので、構造体全体の情報をまとめて比較すると、パディング領域のメモリ情報も同時に比較することになる。ここで、仮にメンバ本体の情報が両者で完全に一致していたとしても、パディング領域の情報が異なっていたら不一致という判定がなされてしまうことになり、知りたい情報と異なってしまう。よって、構造体内のメンバ本体の値が一致しているかどうかを判定するためには、逐次的に各メンバを比較する必要がある。

## ・trickが行った細工の確認

以下のプログラムを細工の前後で行なった。
1行目のコードでは、メンバbの1バイト分のメモリ情報の一致判定をしている。
一方、2行目のコードでは、メンバbの後ろのパディング領域も含めた8バイト分のメモリ情報の一致判定をしている。
```
printf("%s\n", (!memcmp(&h1.a+1,&h2.a+1,sizeof(char)))?"true":"false");
printf("%s\n", (!memcmp(&h1.a+1,&h2.a+1,sizeof(double)))?"true":"false");
```
まず細工の前では、以下のような出力になった。これはパディング領域のメモリ情報も含めて完全に一致しているという意味である。
```
true
true
```
続いて、細工の後に実行すると、以下のような出力が返された。これが意味するところは、メンバ本体の値は一致しているが、その後ろのパディング領域の情報が異なっているということである。
```
true
false
```

続いて、以下のコードにより、trickの前後でメモリの中身がどのように変化したかを確認した。
```
char *p1 = (char*)&h1; 
char *p2 = (char*)&h2;
for (int i = 0; i < sizeof(Obj); i++) {
    printf("p + %d : '%c' => '%c'\n", i, *p1, *p2);
    p1++;
    p2++;
}
```
すると、以下のような出力が返された。この結果からchar型のメンバのメモリの後ろの部分に、"hello "という文字が新たに追加されたことがわかる。
```
p + 0 : '' => ''
p + 1 : '' => ''
p + 2 : '' => ''
p + 3 : '' => ''
p + 4 : '' => ''
p + 5 : '' => ''
p + 6 : '�' => '�'
p + 7 : '?' => '?'
p + 8 : 'c' => 'c'
p + 9 : '' => 'h'
p + 10 : '' => 'e'
p + 11 : '' => 'l'
p + 12 : '' => 'l'
p + 13 : '' => 'o'
p + 14 : '' => ' '
p + 15 : '' => ''
p + 16 : '' => ''
p + 17 : '' => ''
p + 18 : '' => ''
p + 19 : '' => ''
p + 20 : '' => ''
p + 21 : '' => ''
p + 22 : '' => ''
p + 23 : '@' => '@'
```